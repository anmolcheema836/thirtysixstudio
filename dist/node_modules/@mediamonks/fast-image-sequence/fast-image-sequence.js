class u {
  index;
  images = [];
  priority = 0;
  constructor(e) {
    this.index = e;
  }
  get image() {
    return this.images.find((e) => e.image !== void 0)?.image;
  }
  async getImage() {
    return new Promise(async (e, t) => {
      if (this.image !== void 0)
        e(this.image);
      else {
        const s = this.images[this.images.length - 1];
        s ? s.fetchImage().then((i) => e(i)).catch(() => t()) : t();
      }
    });
  }
  async fetchImage() {
    return this.images.find((e) => e.available)?.fetchImage();
  }
  releaseImage() {
    this.images.forEach((e) => e.releaseImage());
  }
}
function w() {
  const r = document.createElement("div");
  return Object.assign(r.style, {
    position: "absolute",
    top: "0",
    left: "0",
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    color: "white",
    padding: "8px",
    fontSize: "12px",
    zIndex: "1000",
    lineHeight: "20px"
  }), r;
}
function v(r, e) {
  r.innerHTML = `<pre>${e}</pre>`;
}
class b {
  available = !0;
  loading = !1;
  frame;
  _image;
  context;
  constructor(e, t) {
    this.context = e, this.frame = t;
  }
  get image() {
    if (this._image !== void 0 && !this.loading)
      return this._image;
  }
  set image(e) {
    e !== this._image && (this.releaseImage(), this._image = e);
  }
  get imageURL() {
    return this.context.getImageURL(this.frame.index);
  }
  reset() {
    this.releaseImage(), this._image = void 0;
  }
  async fetchImage() {
    return this.context.fetchImage(this);
  }
  releaseImage() {
    this._image && (this._image instanceof ImageBitmap && this._image.close(), this._image = void 0), this.loading = !1;
  }
}
const g = 0, I = 1, f = 2;
class l {
  static defaultOptions = {
    tarURL: void 0,
    imageURL: void 0,
    useWorker: !z(),
    maxCachedImages: 32,
    maxConnectionLimit: 4,
    available: void 0,
    image: void 0,
    timeout: -1
  };
  options;
  index = -0;
  initialized = !1;
  context;
  constructor(e, t, s) {
    this.context = e, this.index = t, this.options = { ...l.defaultOptions, ...s }, this.options.maxCachedImages = m(Math.floor(this.options.maxCachedImages), 1, this.context.options.frames), this.context.frames.forEach((i) => i.images[t] = new b(this, i));
  }
  get type() {
    return f;
  }
  get images() {
    return this.context.frames.map((e) => e.images[this.index]);
  }
  /**
   * Set the maximum number of images to cache.
   * @param maxCache - The maximum number of images to cache.
   * @param onProgress - A callback function that is called with the progress of the loading.
   */
  setMaxCachedImages(e, t) {
    const s = this.initialized ? this.images.filter((i) => i.available).length : this.context.options.frames;
    return this.options.maxCachedImages = m(e, 1, s), this.context.onLoadProgress(t);
  }
  getImageURL(e) {
  }
  async loadResources() {
    for (const e of this.images)
      e.available = this.available(e, e.available);
    if (!this.images[0]?.available)
      throw new Error(`No image available for index 0 in ImageSource${this.index} (${this.images[0]?.imageURL})`);
    this.initialized = !0, this.setMaxCachedImages(this.options.maxCachedImages);
  }
  process(e) {
    e();
    let { numLoading: t, numLoaded: s } = this.getLoadStatus();
    const i = this.options.maxConnectionLimit, a = this.images.filter((o) => o.available && o.image === void 0 && !o.loading && o.frame.priority).sort((o, c) => o.frame.priority - c.frame.priority), n = this.images.filter((o) => o.available && o.image !== void 0 && !o.loading).sort((o, c) => c.frame.priority - o.frame.priority).shift()?.frame.priority ?? 1e10;
    for (; t < i && a.length > 0; ) {
      const o = a.shift();
      (o.frame.priority < n || s < this.options.maxCachedImages - t) && (o.loading = !0, this.fetchImage(o).then((c) => {
        o.loading && (o.loading = !1, o.image = c, e(), this.releaseImageWithLowestPriority());
      }).catch((c) => {
        o.reset(), console.error(c);
      })), t++;
    }
  }
  getLoadStatus() {
    const e = this.images.filter((a) => a.loading).length, t = this.images.filter((a) => a.image !== void 0).length, s = this.options.maxCachedImages;
    return { progress: Math.max(0, t - e) / Math.max(1, s), numLoading: e, numLoaded: t, maxLoaded: s };
  }
  async fetchImage(e) {
    return this.options.image ? this.options.image(e.frame.index) : new Promise((t, s) => {
      s("Not implemented");
    });
  }
  destruct() {
    this.images.forEach((e) => e.reset());
  }
  available(e, t = !0) {
    return this.options.available ? t && this.options.available(e.frame.index) : t;
  }
  releaseImageWithLowestPriority() {
    const e = this.images.filter((t) => t.image !== void 0 && !t.loading);
    if (e.length > this.options.maxCachedImages) {
      const t = e.sort((s, i) => s.frame.priority - i.frame.priority).pop();
      t && t.releaseImage();
    }
  }
}
function x(r, e) {
  return new Promise((t, s) => {
    const i = new XMLHttpRequest();
    i.open("GET", r, !0), i.responseType = "arraybuffer", i.onprogress = function(a) {
      if (a.lengthComputable && e) {
        const h = a.loaded / a.total;
        e(h);
      }
    }, i.onload = function() {
      i.status === 200 ? (e && e(1), t(i.response)) : s(new Error(`Error ${i.status}: ${i.statusText}`));
    }, i.onerror = function() {
      s(new Error("Request failed"));
    }, i.send();
  });
}
function y(r, e) {
  return new Promise((t, s) => {
    r.onerror = (i) => s(i), r.decoding = "async", r.src = e, r.decode().then(() => {
      t(r);
    }).catch((i) => {
      console.error(i), s(i);
    });
  });
}
const L = `let buffer;

self.onmessage = async (e) => {
    if (e.data.cmd === 'init') {
        buffer = e.data.buffer;
    } else if (e.data.cmd === 'load') {
        loadImage(e.data.offset, e.data.size, e.data.index);
    }
};

async function loadImage(offset, size, index) {
    const view = new Uint8Array(buffer, offset, size);
    const blob = new Blob([view], {});
    const imageBitmap = await createImageBitmap(blob);
    postMessage({msg: 'done', imageBitmap, index}, [imageBitmap]);
}`;
class F {
  fileInfo = [];
  buffer;
  options;
  worker;
  resolve = [];
  defaultOptions = {
    useWorker: !0
  };
  constructor(e, t = {}) {
    this.buffer = e, this.options = { ...this.defaultOptions, ...t };
    let s = 0;
    for (; s < this.buffer.byteLength - 512; ) {
      const i = this.readFileName(s);
      if (i.length == 0)
        break;
      const a = this.readFileSize(s);
      this.fileInfo.push({
        name: i,
        size: a,
        header_offset: s
      }), s += 512 + 512 * Math.trunc(a / 512), a % 512 && (s += 512);
    }
  }
  getInfo(e) {
    return this.fileInfo.find((t) => t.name.includes(e));
  }
  getImage(e, t) {
    return this.options.useWorker ? (this.worker || (this.worker = this.createWorker()), new Promise((s, i) => {
      const a = this.getInfo(e);
      a && !this.resolve[t] ? (this.resolve[t] = s, this.worker.postMessage({ cmd: "load", offset: a.header_offset + 512, size: a.size, index: t })) : i("Image already loading from tar");
    })) : new Promise((s, i) => {
      const a = this.getBlob(e, "image");
      a !== void 0 ? createImageBitmap(a).then((h) => {
        s(h);
      }).catch(() => {
        i();
      }) : i();
    });
  }
  destruct() {
    this.worker && this.worker.terminate(), this.resolve = [];
  }
  readFileName(e) {
    const t = new Uint8Array(this.buffer, e, 100), s = t.indexOf(0);
    return new TextDecoder().decode(t.slice(0, s));
  }
  readFileSize(e) {
    const t = new Uint8Array(this.buffer, e + 124, 12);
    let s = "";
    for (let i = 0; i < 11; i++)
      s += String.fromCharCode(t[i]);
    return parseInt(s, 8);
  }
  // worker functionality
  getBlob(e, t = "") {
    const s = this.getInfo(e);
    if (s) {
      const i = new Uint8Array(this.buffer, s.header_offset + 512, s.size);
      return new Blob([i], { type: t });
    }
  }
  createWorker() {
    const e = new Blob([L], { type: "application/javascript" }), t = new Worker(URL.createObjectURL(e));
    return t.addEventListener("message", (s) => {
      const i = this.resolve[s.data.index];
      this.resolve[s.data.index] = void 0, i ? i(s.data.imageBitmap) : s.data.imageBitmap.close();
    }), t.postMessage({ cmd: "init", buffer: this.buffer }, [this.buffer]), t;
  }
}
class R extends l {
  tarball;
  tarLoadProgress = 0;
  get type() {
    return I;
  }
  async loadResources() {
    if (this.options.tarURL !== void 0) {
      const e = await x(this.options.tarURL, (t) => {
        this.tarLoadProgress = t;
      });
      this.tarball = new F(e, { useWorker: this.options.useWorker }), this.context.log("Tarball", this.tarball);
    }
    return super.loadResources();
  }
  getImageURL(e) {
    return this.options.imageURL ? this.options.imageURL(e) : void 0;
  }
  getLoadStatus() {
    const e = super.getLoadStatus();
    return e.progress = this.tarLoadProgress / 2 + e.progress / 2, e;
  }
  async fetchImage(e) {
    return new Promise((t, s) => {
      e.available ? this.tarball?.getImage(e.imageURL || "", e.frame.index).then((i) => {
        t(i);
      }).catch((i) => {
        s(i);
      }) : s(`Image not available or already loading ${e.imageURL} ${e.loading}`);
    });
  }
  destruct() {
    super.destruct(), this.tarball?.destruct(), this.tarball = void 0;
  }
  available(e, t = !0) {
    return t = t && e.imageURL !== void 0 && this.tarball?.getInfo(e.imageURL) !== void 0, super.available(e, t);
  }
}
const k = `self.onmessage = async (e) => {
    if (e.data.cmd === 'load') {
        await loadImage(e.data.url, e.data.index);
    }
};

async function loadImage(url, index) {
    const response = await fetch(url);
    if (!response.ok) throw "network error";
    const imageBitmap = await createImageBitmap(await response.blob());
    postMessage({msg: 'done', imageBitmap, index}, [imageBitmap]);
}`;
class P {
  index = -1e10;
  worker;
  resolve;
  constructor() {
    const e = new Blob([k], { type: "application/javascript" }), t = new Worker(URL.createObjectURL(e));
    t.addEventListener("message", (s) => {
      this.resolve && s.data.index === this.index ? this.resolve(s.data.imageBitmap) : s.data.imageBitmap.close();
    }), this.worker = t;
  }
  load(e, t) {
    return this.index = e, new Promise((s, i) => {
      this.resolve = s, this.worker.postMessage({ cmd: "load", url: t, index: e });
    });
  }
  abort() {
    this.index = -1e10, this.resolve = void 0;
  }
}
const d = [];
function U() {
  return d.length === 0 && d.push(new P()), d.shift();
}
function C(r) {
  r.abort(), d.push(r);
}
class M extends l {
  get type() {
    return g;
  }
  getImageURL(e) {
    return this.options.imageURL ? new URL(this.options.imageURL(e), window.location.href).href : void 0;
  }
  async fetchImage(e) {
    return new Promise((t, s) => {
      if (e.imageURL)
        if (this.options.useWorker) {
          const i = U();
          i.load(this.index, e.imageURL).then((a) => {
            t(a), C(i);
          }).catch((a) => s(a));
        } else {
          const i = new Image();
          y(i, e.imageURL).then(() => {
            t(i);
          }).catch((a) => s(a));
        }
      else
        s("Image url not set or image allready loading");
    });
  }
}
function z() {
  return typeof navigator < "u" && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
function m(r, e, t) {
  return Math.min(Math.max(r, e), t);
}
class p {
  static defaultOptions = {
    frames: 1,
    src: [],
    loop: !1,
    poster: void 0,
    fillStyle: "#00000000",
    objectFit: "cover",
    clearCanvas: !1,
    // clear canvas before drawing
    showDebugInfo: !1,
    name: "FastImageSequence",
    horizontalAlign: 0.5,
    verticalAlign: 0.5
  };
  canvas;
  options;
  width = 0;
  height = 0;
  frame = 0;
  log;
  frames = [];
  sources = [];
  context;
  tickFuncs = [];
  startTime = -1;
  animationRequestId = 0;
  container;
  resizeObserver;
  mutationOberver;
  clearCanvas = !0;
  speed = 0;
  prevFrame = 0;
  direction = 1;
  lastFrameDrawn = -1;
  destructed = !1;
  logElement;
  initialized = !1;
  posterImage;
  timeFrameVisible = 0;
  /**
   * Creates an instance of FastImageSequence.
   *
   * @param {HTMLElement} container - The HTML element where the image sequence will be displayed.
   * @param {FastImageSequenceOptions} options - The options for the image sequence.
   *
   * @throws {Error} If the number of frames is less than or equal to 0.
   */
  constructor(e, t) {
    if (this.options = { ...p.defaultOptions, ...t }, this.options.frames <= 0)
      throw new Error("FastImageSequence: frames must be greater than 0");
    this.container = e, this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.context.fillStyle = this.options.fillStyle, this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), Object.assign(this.canvas.style, {
      inset: "0",
      width: "100%",
      height: "100%",
      margin: "0",
      display: "block"
    }), this.container.appendChild(this.canvas), this.resizeObserver = new ResizeObserver(() => {
      this.clearCanvas = !0, this.lastFrameDrawn < 0 && this.posterImage && this.drawImage(this.posterImage);
    }), this.resizeObserver.observe(this.canvas), this.mutationOberver = new MutationObserver(() => {
      this.container.isConnected || (console.error("FastImageSequence: container is not connected to the DOM, fast image sequence will be destroyed"), this.destruct());
    }), this.mutationOberver.observe(e, { childList: !0 }), this.frames = Array.from({ length: this.options.frames }, (i, a) => new u(a)), this.log = this.options.showDebugInfo ? console.log : () => {
    };
    const s = this.options.src instanceof Array ? this.options.src : [this.options.src];
    this.sources = s.map((i, a) => i.tarURL !== void 0 ? new R(this, a, i) : i.imageURL !== void 0 ? new M(this, a, i) : new l(this, a, i)), this.loadResources().then(() => {
      this.initialized = !0, this.log("Frames", this.frames), this.log("Options", this.options), this.options.showDebugInfo && (this.logElement = w(), this.container.appendChild(this.logElement), this.tick(() => this.logDebugStatus(this.logElement))), this.drawingLoop(-1);
    });
  }
  /**
   * Get whether the image sequence is playing.
   */
  get playing() {
    return this.speed !== 0;
  }
  /**
   * Get whether the image sequence is paused.
   */
  get paused() {
    return !this.playing;
  }
  /**
   * Get the current progress of the image sequence loading.
   */
  get loadProgress() {
    return this.sources.reduce((e, t) => e + t.getLoadStatus().progress, 0) / this.sources.length;
  }
  /**
   * Get the current progress of the image sequence.
   * @returns {number} - The current progress of the image sequence.
   */
  get progress() {
    return this.index / (this.options.frames - 1);
  }
  /**
   * Set the current progress of the image sequence.
   * @param {number} value - The progress value to set.
   */
  set progress(e) {
    this.frame = (this.options.frames - 1) * e;
  }
  /**
   * Get the first ImageSource from the sources array.
   * @returns {ImageSource} - The first ImageSource object in the sources array.
   */
  get src() {
    return this.sources[0];
  }
  get index() {
    return this.wrapIndex(this.frame);
  }
  /**
   * Returns a promise that resolves when the image sequence is ready to play.
   */
  ready() {
    return new Promise((e) => {
      const t = () => {
        this.sources.every((s) => s.initialized) ? e() : setTimeout(t, 16);
      };
      t();
    });
  }
  /**
   * Register a tick function to be called on every frame update.
   *
   * @param func - The function to be called.
   */
  tick(e) {
    this.tickFuncs.push(e);
  }
  /**
   * Start playing the image sequence at a specified frame rate.
   * @param {number} [fps=30] - The frame rate to play the sequence at.
   */
  play(e = 30) {
    this.speed = e;
  }
  /**
   * Stop playing the image sequence.
   */
  stop() {
    this.speed = 0;
  }
  /**
   * Get the image of a specific frame.
   * @param {number} index - The index of the frame.
   * @returns {Promise<HTMLImageElement | ImageBitmap | undefined>} - A promise that resolves with the image of the frame.
   */
  async getFrameImage(e) {
    return await this.frames[this.wrapIndex(e)].fetchImage();
  }
  /**
   * Register a callback function that is called with the progress of the loading.
   * The function returns a promise that resolves when progress reaches 1.
   * @param onProgress - A callback function that is called with the progress of the loading.
   */
  async onLoadProgress(e) {
    let t = this.loadProgress;
    return new Promise((s) => {
      const i = () => {
        this.loadProgress >= 1 ? (e && e(1), s(!0)) : (e && t !== this.loadProgress && (e(this.loadProgress), t = this.loadProgress), setTimeout(i, 16));
      };
      i();
    });
  }
  /**
   * Destruct the FastImageSequence instance.
   */
  destruct() {
    this.destructed || (this.destructed = !0, this.animationRequestId && cancelAnimationFrame(this.animationRequestId), this.resizeObserver.disconnect(), this.mutationOberver.disconnect(), this.container.removeChild(this.canvas), this.logElement && (this.container.removeChild(this.logElement), this.logElement = void 0), this.canvas.replaceWith(this.canvas.cloneNode(!0)), this.sources.forEach((e) => e.destruct()), this.frames.forEach((e) => e.releaseImage()));
  }
  /**
   * Set the size and alignment of the image sequence on the canvas.
   *
   * @param {Partial<FastImageSequenceDisplayOptions>} options - An object containing the size and alignment options.
   * @property {string} options.objectFit - How the image should be resized to fit the canvas. It can be either 'contain' or 'cover'.
   * @property {number} options.horizontalAlign - The horizontal alignment of the image. It should be a number between 0 and 1.
   * @property {number} options.verticalAlign - The vertical alignment of the image. It should be a number between 0 and 1.
   */
  setDisplayOptions(e) {
    this.options = { ...this.options, ...e }, this.clearCanvas = !0;
  }
  setLoadingPriority() {
    const e = this.index;
    this.frames.forEach((t) => {
      t.priority = Math.abs(t.index + 0.25 - e), this.options.loop && (t.priority = Math.min(t.priority, this.options.frames - t.priority));
    });
  }
  async loadResources() {
    if (this.options.poster) {
      this.log("Poster image", this.options.poster);
      const e = new Image();
      e.src = this.options.poster, await e.decode().then(() => this.drawImage(this.posterImage = e)).catch((t) => this.log(t));
    }
    await Promise.all(this.sources.map((e) => e.loadResources())), await this.getFrameImage(0);
  }
  wrapIndex(e) {
    const t = e | 0;
    return this.wrapFrame(t);
  }
  wrapFrame(e) {
    return this.options.loop ? (e % this.options.frames + this.options.frames) % this.options.frames : m(e, 0, this.options.frames - 1);
  }
  async drawingLoop(e = 0) {
    if (this.destructed)
      return;
    e /= 1e3;
    const t = this.initialized ? this.startTime < 0 ? 1 / 60 : Math.min(e - this.startTime, 1 / 30) : 0;
    this.startTime = e > 0 ? e : -1, this.frame - this.prevFrame < 0 && (this.direction = -1), this.frame - this.prevFrame > 0 && (this.direction = 1), this.frame += this.speed * t, this.frame = this.wrapFrame(this.frame);
    const s = this.index, i = this.canvas.getBoundingClientRect();
    if (i.top < window.innerHeight && i.bottom > 0) {
      this.frames.forEach((n) => {
        n.priority = Math.abs(n.index - s);
        let o = Math.sign(this.frame - this.prevFrame);
        if (this.options.loop) {
          const c = this.options.frames - n.priority;
          c < n.priority && (n.priority = c);
        }
        n.priority += this.direction * o === -1 ? this.frames.length : 0;
      }), this.frames.sort((n, o) => o.priority - n.priority);
      const h = this.frames.filter((n) => n.image !== void 0).pop();
      h && this.drawFrame(h);
    }
    this.wrapIndex(this.frame) === this.wrapIndex(this.prevFrame) ? this.timeFrameVisible += t : this.timeFrameVisible = 0, this.process(), this.tickFuncs.forEach((h) => h(t)), this.prevFrame = this.frame, this.animationRequestId = requestAnimationFrame((h) => this.drawingLoop(h));
  }
  drawFrame(e) {
    const t = e.image;
    t && (this.lastFrameDrawn = e.index, this.drawImage(t));
  }
  drawImage(e) {
    const t = e.naturalWidth || e.width || e.videoWidth, s = e.naturalHeight || e.height || e.videoHeight, i = this.container.offsetWidth / this.container.offsetHeight, a = t / s;
    if (this.width = Math.max(this.width, t), this.height = Math.max(this.height, s), this.options.objectFit === "contain") {
      const o = i > a ? this.height * i : this.width, c = i > a ? this.height : this.width / i;
      (this.canvas.width !== o || this.canvas.height !== this.height) && (this.canvas.width = o, this.canvas.height = c);
    } else {
      const o = i > a ? this.width : this.height * i, c = i > a ? this.width / i : this.height;
      (this.canvas.width !== o || this.canvas.height !== this.height) && (this.canvas.width = o, this.canvas.height = c);
    }
    const h = (this.canvas.width - this.width) * this.options.horizontalAlign, n = (this.canvas.height - this.height) * this.options.verticalAlign;
    (this.clearCanvas || this.options.clearCanvas) && (this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.clearCanvas = !1), this.context.drawImage(e, 0, 0, t, s, h, n, this.width, this.height);
  }
  process() {
    for (const e of this.sources)
      this.timeFrameVisible >= e.options.timeout / 1e3 && e.process(() => this.setLoadingPriority());
  }
  logDebugStatus(e) {
    const t = (i) => `${Math.abs(i * 100).toFixed(1).padStart(5, " ")}%`;
    let s = `${this.options.name} - frames: ${this.frames.length}, loop: ${this.options.loop}, objectFit: ${this.options.objectFit}
 loadProgress ${t(this.loadProgress)}, last frame drawn ${this.lastFrameDrawn}/${this.index}
`;
    for (const i of this.sources) {
      const { progress: a, numLoading: h, numLoaded: n, maxLoaded: o } = i.getLoadStatus();
      s += ` src[${i.index}] ${i.type === g ? "image:" : i.type === f ? "code: " : "tar:  "} ${t(a)}, numLoading: ${h}, numLoaded: ${n}/${o}${i.options.useWorker ? ", use worker" : ""}
`;
    }
    v(e, s);
  }
}
export {
  p as FastImageSequence,
  m as clamp,
  z as isMobile
};
